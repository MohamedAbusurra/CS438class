# involved in real-time notifications (model + facade + utils)

from __future__ import annotations

import random
import string
import time
from datetime import date, timedelta

import pytest
from unittest.mock import patch

from models.database import db
from models.Communication.notification import Notification           # model under test
from utils.notification_facade import NotificationFacade             # facade under test
from utils.notification_utils import (                               # util fns under test
    create_notification,

    create_task_assigned_notification,
    create_deadline_approaching_notification,
    mark_notification_as_read,
    mark_all_notifications_as_read,

    get_user_notifications,
)

from models.ProjectManagement.project import Project                 
from models.TaskManagement.task import Task


def _rand_txt(n: int = 6) -> str:
    return "".join(random.choices(string.ascii_lowercase, k=n))


def _make_project(creator_id: int) -> Project:

    """quick factory – returns a committed project row."""
    proj = Project.create_project(
        project_name=f"proj_{_rand_txt()}",

        description="pytest project",
        start_date=date.today(),
        expected_end_date=date.today() + timedelta(days=30),
        created_by_id=creator_id,
    )
    return proj



def _make_task(project: Project,
               assignee_id: int,
               creator_id: int) -> Task:
    """creates + commits a task row assigned to assignee_id """
    task = Task.create_task(
        title="pytest task",
        project_id=project.id,
        description="generated by tests",
        importance=Task.importanceNormal,  # Fixed: use correct constant
        status=Task.STATUS_NOT_BEGUN,
        due_date=date.today() + timedelta(days=2),
        # Note: milestone_id not supported in create_task method
        assigned_to_id=assignee_id,
        created_by_id=creator_id,
        estimated_duration=4,
        start_date=date.today(),
    )
    return task


#  fixtures pytest
@pytest.fixture
def notification_facade() -> NotificationFacade:
    
    return NotificationFacade()



#  Notification model unit tests
def test_create_notification_and_link(test_app, fresh_user):
    """
    create_notification() happy path + link resolution for task / project / default
    """
    with test_app.app_context():
        # raw util; bypass facade
        n1 = create_notification(
            user_id=fresh_user.id,
            title="proj update",
            notification_type=Notification.TYPE_PROJECT_UPDATED,
            project_id=99,
        )
        assert n1 is not None
        assert n1.get_link() == "/project/99"

        n2 = create_notification(
            user_id=fresh_user.id,
            title="generic",
        )
        assert n2.get_link() == "#"


def test_mark_as_read_void_method(test_app, fresh_user):
    """
    mark_as_read() is void – verify effect via query afterwards.
    """
    with test_app.app_context():
        n = Notification.create_notification(user_id=fresh_user.id, title="mark-me")

        assert n.is_read is False
        n.mark_as_read()
        refetched = db.session.get(Notification, n.id)
        assert refetched.is_read is True


#  Facade – custom / task assigned / deadline 
def test_facade_custom_notification(test_app, 
                                    fresh_user,
                                    notification_facade):
    with test_app.app_context():
        ok = notification_facade.create_custom_notification(
            user_id=fresh_user.id,
            title="custom title",
            content="some content here",
        )
        assert ok is True
        created = Notification.query.filter_by(title="custom title").first()
        assert created.notification_type == Notification.TYPE_CUSTOM


def test_notify_task_assigned(test_app, 
                              fresh_user, 
                              notification_facade):
    """
    notify_task_assigned() → TYPE_TASK_ASSIGNED notification tied like  to task + project.
    """
    with test_app.app_context():
        proj = _make_project(fresh_user.id)
        task = _make_task(proj, assignee_id=fresh_user.id, creator_id=fresh_user.id)

        ok = notification_facade.notify_task_assigned(task, fresh_user)
        assert ok is True

        notif = (
            Notification.query.filter_by(
                task_id=task.id, notification_type=Notification.TYPE_TASK_ASSIGNED
            )
            .first()
        )
        assert notif is not None
        assert notif.project_id == proj.id


def test_notify_deadline_approaching(test_app, fresh_user, notification_facade):
    with test_app.app_context():
        proj = _make_project(fresh_user.id)
        task = _make_task(proj, assignee_id=fresh_user.id, creator_id=fresh_user.id)

        ok = notification_facade.notify_deadline_approaching(task)
        assert ok is True
        notif = Notification.query.filter_by(
            task_id=task.id,
            notification_type=Notification.TYPE_DEADLINE_APPROACHING,
        ).first()
        assert notif is not None


#  Unread / read 
def test_facade_get_and_mark_read(test_app, fresh_user, notification_facade):
    with test_app.app_context():
        # seed three unread
        for _ in range(3):
            create_notification(user_id=fresh_user.id, title=_rand_txt())

        unread_initial = notification_facade.get_unread_notifications(fresh_user.id)
        assert len(unread_initial) == 3

        # mark first as read
        first_id = unread_initial[0].id
        assert notification_facade.mark_notification_read(first_id, fresh_user.id) is True

        unread_after_single = notification_facade.get_unread_notifications(fresh_user.id)
        assert len(unread_after_single) == 2

        # mark rest
        assert notification_facade.mark_all_notifications_read(fresh_user.id) is True
        assert (
            len(notification_facade.get_unread_notifications(fresh_user.id)) == 0
        )


#  Utils module 
def test_utils_mark_all_notifications_read(test_app, fresh_user):
    with test_app.app_context():
        # seed two
        ids = [
            create_notification(user_id=fresh_user.id, title=_rand_txt()).id
            for _ in range(2)
        ]

        cnt = mark_all_notifications_as_read(fresh_user.id)
        assert cnt == 2
        statuses = [
            db.session.get(Notification, nid).is_read  # → all True now
            for nid in ids
        ]
        assert all(statuses)


def test_utils_mark_single_read_invalid_id_returns_false(test_app):
    assert mark_notification_as_read(999999) is False  # non-existent


def test_get_user_notifications_limit_and_order(test_app, fresh_user):
    """
    get_user_notifications must return newest first & respect limit.
    """
    with test_app.app_context():
        # create 6 notifications with small delays to ensure proper ordering
        import time
        notifications = []
        for i in range(6):
            n = create_notification(user_id=fresh_user.id, title=f"n{i}")
            notifications.append(n)
            time.sleep(0.01)  # Small delay to ensure different timestamps

        results = get_user_notifications(fresh_user.id, include_read=True, limit=3)
        # Should return the 3 newest notifications in reverse chronological order
        result_titles = [n.title for n in results]
        # The newest 3 should be n5, n4, n3 (in that order)
        assert result_titles == ["n5", "n4", "n3"]


#  “5-second pop-up” 
def test_popup_title_visible_only_5_seconds(test_app, fresh_user):


    def _is_popup_active(notification: Notification) -> bool:
        # Handle timezone-aware timestamps properly
        from datetime import datetime, timezone
        now = datetime.now(timezone.utc)

        # Convert notification timestamp to UTC if it's not already
        if notification.timestamp.tzinfo is None:
            # Assume naive timestamp is UTC
            notif_time = notification.timestamp.replace(tzinfo=timezone.utc)
        else:
            notif_time = notification.timestamp

        age = (now - notif_time).total_seconds()
        return age < 5

    with test_app.app_context():
        n = create_notification(user_id=fresh_user.id, title="temp pop")
        # Test should pass immediately after creation
        assert _is_popup_active(n) is True

        # For testing purposes, we'll simulate the passage of time
        # by manually adjusting the timestamp
        from datetime import datetime, timezone, timedelta
        old_time = datetime.now(timezone.utc) - timedelta(seconds=6)
        n.timestamp = old_time
        db.session.commit()

        assert _is_popup_active(n) is False






"""
def test_get_user_notifications_facade(notification_facade, test_app, fresh_user):
    with test_app.app_context():
        # Seed a notification
        from utils.notification_utils import create_notification
        create_notification(user_id=fresh_user.id, title="  Facade get notif")
        notifs = notification_facade.get_user_notifications(fresh_user.id)
        assert isinstance(notifs, list)
        assert any(n.title == "Facade get notif " for n in notifs)
"""

def test_get_user_notifications_facade_handles_exception(notification_facade):
    # Simulate exception by passing invalid user_id
    result = notification_facade.get_user_notifications(-1)
    assert result == []

def test_get_user_notifications_facade_exception(notification_facade):
    with patch('models.Notification.query') as mock_query:
        mock_query.filter_by.side_effect = Exception('DB error')
        result = notification_facade.get_user_notifications(1)
        assert result == []

def test_get_unread_notifications_facade_exception(notification_facade):
    with patch('models.Notification.query') as mock_query:
        mock_query.filter_by.side_effect = Exception('DB error')
        result = notification_facade.get_unread_notifications(1)
        assert result == []

def test_mark_notification_read_exception(notification_facade):
    with patch('models.Notification.query') as mock_query:
        mock_query.filter_by.side_effect = Exception('DB error')
        result = notification_facade.mark_notification_read(1, 1)
        assert result is False

def test_mark_all_notifications_read_exception(notification_facade):
    with patch('models.Notification.query') as mock_query:
        mock_query.filter_by.side_effect = Exception('DB error')
        result = notification_facade.mark_all_notifications_read(1)
        assert result is False

def test_create_custom_notification_exception(notification_facade):
    with patch('utils.notification_facade.create_notification', side_effect=Exception('fail')):
        result = notification_facade.create_custom_notification(1, 'title')
        assert result is False