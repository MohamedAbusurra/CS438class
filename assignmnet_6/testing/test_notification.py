
# involved in “real-time notifications” (model + facade + utils).
#
# run with

#     pytest -q tests/test_real_time_notifications.py

# NOTE: relies on the shared fixtures declared in tests/conftest.py
from __future__ import annotations

import random
import string
import time
from datetime import date, timedelta

import pytest

from models.database import db
from models.Communication.notification import Notification           # model under test
from utils.notification_facade import NotificationFacade             # facade under test
from utils.notification_utils import (                               # util fns under test
    create_notification,

    create_task_assigned_notification,
    create_deadline_approaching_notification,
    mark_notification_as_read,
    mark_all_notifications_as_read,

    get_user_notifications,
)

from models.ProjectManagement.project import Project                 
from models.TaskManagement.task import Task


def _rand_txt(n: int = 6) -> str:
    return "".join(random.choices(string.ascii_lowercase, k=n))


def _make_project(creator_id: int) -> Project:

    """quick factory – returns a committed project row."""
    proj = Project.create_project(
        project_name=f"proj_{_rand_txt()}",

        description="pytest project",
        start_date=date.today(),
        expected_end_date=date.today() + timedelta(days=30),
        created_by_id=creator_id,
    )
    return proj



def _make_task(project: Project, 
               assignee_id: int,
               creator_id: int) -> Task:
    """creates + commits a task row assigned to assignee_id """
    task = Task.create_task(

        title="pytest task",
        project_id=project.id,
        description="generated by tests",
        importance=Task.IMPORTANCE_NORMAL,
        status=Task.STATUS_NOT_BEGUN,

        due_date=date.today() + timedelta(days=2),
        milestone_id=None,
        assigned_to_id=assignee_id,
        created_by_id=creator_id,
        estimated_duration=4,
        start_date=date.today(),
    )
    return task


#  fixtures pytest
@pytest.fixture
def notification_facade() -> NotificationFacade:
    
    return NotificationFacade()



#  Notification model unit tests
def test_create_notification_and_link(test_app, fresh_user):
    """
    create_notification() happy path + link resolution for task / project / default
    """
    with test_app.app_context():
        # raw util; bypass facade
        n1 = create_notification(
            user_id=fresh_user.id,
            title="proj update",
            notification_type=Notification.TYPE_PROJECT_UPDATED,
            project_id=99,
        )
        assert n1 is not None
        assert n1.get_link() == "/project/99"

        n2 = create_notification(
            user_id=fresh_user.id,
            title="generic",
        )
        assert n2.get_link() == "#"


def test_mark_as_read_void_method(test_app, fresh_user):
    """
    mark_as_read() is void – verify effect via query afterwards.
    """
    with test_app.app_context():
        n = Notification.create_notification(user_id=fresh_user.id, title="mark-me")

        assert n.is_read is False
        n.mark_as_read()
        refetched = db.session.get(Notification, n.id)
        assert refetched.is_read is True


#  Facade – custom / task assigned / deadline 
def test_facade_custom_notification(test_app, 
                                    fresh_user,
                                    notification_facade):
    with test_app.app_context():
        ok = notification_facade.create_custom_notification(
            user_id=fresh_user.id,
            title="custom title",
            content="some content here",
        )
        assert ok is True
        created = Notification.query.filter_by(title="custom title").first()
        assert created.notification_type == Notification.TYPE_CUSTOM


def test_notify_task_assigned(test_app, 
                              fresh_user, 
                              notification_facade):
    """
    notify_task_assigned() → TYPE_TASK_ASSIGNED notification tied like  to task + project.
    """
    with test_app.app_context():
        proj = _make_project(fresh_user.id)
        task = _make_task(proj, assignee_id=fresh_user.id, creator_id=fresh_user.id)

        ok = notification_facade.notify_task_assigned(task, fresh_user)
        assert ok is True

        notif = (
            Notification.query.filter_by(
                task_id=task.id, notification_type=Notification.TYPE_TASK_ASSIGNED
            )
            .first()
        )
        assert notif is not None
        assert notif.project_id == proj.id


def test_notify_deadline_approaching(test_app, fresh_user, notification_facade):
    with test_app.app_context():
        proj = _make_project(fresh_user.id)
        task = _make_task(proj, assignee_id=fresh_user.id, creator_id=fresh_user.id)

        ok = notification_facade.notify_deadline_approaching(task)
        assert ok is True
        notif = Notification.query.filter_by(
            task_id=task.id,
            notification_type=Notification.TYPE_DEADLINE_APPROACHING,
        ).first()
        assert notif is not None


#  Unread / read 
def test_facade_get_and_mark_read(test_app, fresh_user, notification_facade):
    with test_app.app_context():
        # seed three unread
        for _ in range(3):
            create_notification(user_id=fresh_user.id, title=_rand_txt())

        unread_initial = notification_facade.get_unread_notifications(fresh_user.id)
        assert len(unread_initial) == 3

        # mark first as read
        first_id = unread_initial[0].id
        assert notification_facade.mark_notification_read(first_id, fresh_user.id) is True

        unread_after_single = notification_facade.get_unread_notifications(fresh_user.id)
        assert len(unread_after_single) == 2

        # mark rest
        assert notification_facade.mark_all_notifications_read(fresh_user.id) is True
        assert (
            len(notification_facade.get_unread_notifications(fresh_user.id)) == 0
        )


#  Utils module 
def test_utils_mark_all_notifications_read(test_app, fresh_user):
    with test_app.app_context():
        # seed two
        ids = [
            create_notification(user_id=fresh_user.id, title=_rand_txt()).id
            for _ in range(2)
        ]

        cnt = mark_all_notifications_as_read(fresh_user.id)
        assert cnt == 2
        statuses = [
            db.session.get(Notification, nid).is_read  # → all True now
            for nid in ids
        ]
        assert all(statuses)


def test_utils_mark_single_read_invalid_id_returns_false(test_app):
    assert mark_notification_as_read(999999) is False  # non-existent


def test_get_user_notifications_limit_and_order(test_app, fresh_user):
    """
    get_user_notifications must return newest first & respect limit.
    """
    with test_app.app_context():
        # create 6 – newest titles have suffix 5,4…
        for i in range(6):
            create_notification(user_id=fresh_user.id, title=f"n{i}")

        results = get_user_notifications(fresh_user.id, include_read=True, limit=3)
        assert [n.title for n in results] == ["n5", "n4", "n3"]


#  “5-second pop-up” 
def test_popup_title_visible_only_5_seconds(test_app, fresh_user):
    

    def _is_popup_active(notification: Notification) -> bool:
        age = (time.time() - notification.timestamp.timestamp())
        return age < 5

    with test_app.app_context():
        n = create_notification(user_id=fresh_user.id, title="temp pop")
        assert _is_popup_active(n) is True
        time.sleep(5.2)  # little over the spec
        assert _is_popup_active(n) is False